#+Title: Projeto 2
#+Author: Ieremies Romero

Basicamente o que eu fiz foi pegar o código do tsp do prof e copiar a classe de subtourelim.

Ela se resume ao método callback:

Essa parte pega qual a função do gurobi nos dá o valor das variáveis baseado no estado da árvore de branch-and-bound.
#+begin_source c++
if (where == GRB_CB_MIPSOL) {
    solution_value = &subtourelim::getSolution;
} else if ((where == GRB_CB_MIPNODE) &&
            (getIntInfo(GRB_CB_MIPNODE_STATUS) ==
            GRB_OPTIMAL)) // node with optimal fractional solution
{
    solution_value = &subtourelim::getNodeRel;
} else
    return;
#+end_source

Depois, separamos os arcos naqueles que possuem valor $1$ (ou suficientemente próximo) e aqueles que possuem valor fracionário, na solução atual

#+begin_source c++
//Stores the edges with fractional values and integer values
vector<Arc> FracArcs, OneArcs;
// produces a subgraph h of g, with arcs a with x[a]==1
// contracted, so we can apply Gomory-Hu tree in a small graph
for (ArcIt e(drone.dg); e != INVALID; ++e) {
    if ((this->*solution_value)(x[e]) > 1 - MY_EPS)
    OneArcs.push_back(e); // stores the edges with x[e]==1
    else if ((this->*solution_value)(x[e]) > MY_EPS)
    FracArcs.push_back(e); // includes edges with 0 < x[e] < 1
} // define the subgraph with edges that have x[e]==1
#+end_source

Usamos Union-Find para achar as componentes contraídas, ou seja, aglutinamos os nós que possuem arestas com valor $1$ em um nó só no novo grafo $h$.
#+begin_source c++
Digraph::NodeMap<int> aux_map(drone.dg);
UnionFind<Digraph::NodeMap<int>> UFNodes(aux_map);
for (Digraph::NodeIt v(drone.dg); v != INVALID; ++v)
UFNodes.insert(v);
for (auto a : OneArcs)
UFNodes.join(drone.dg.source(a), drone.dg.target(a));
#+end_source

Todos os nós que não estão em uma componente descritas acima são colocados em um conjunto separado.
#+begin_src c++
vector<Arc> CrossingArcs;
for (ArcIt e(drone.dg); e != INVALID; ++e)
if (UFNodes.find(drone.dg.source(e)) !=
    UFNodes.find(drone.dg.target(e)))
    CrossingArcs.push_back(e);
#+end_src

Geramos uma lista de nós representantes de cada componente.
#+begin_source c++
vector<bool> ComponentIndex(drone.nnodes);
vector<Graph::Node> Index2h(drone.nnodes);
for (int i = 0; i < drone.nnodes; i++)
ComponentIndex[i] = false;
for (Digraph::NodeIt v(drone.dg); v != INVALID; ++v)
ComponentIndex[UFNodes.find(v)] = true;
#+end_source

Por fim, geramos o grafo $h$. Este grafo terá como nós os componentes descritos acima e como capacidade o valor do arco na solução atual.
#+begin_source c++
Graph h;
EdgeValueMap h_capacity(h);
for (int i = 0; i < drone.nnodes; i++) // add nodes to the graph h
if (ComponentIndex[i])
    Index2h[i] = h.addNode();
for (auto a : FracArcs) {
Digraph::Node u = drone.dg.source(a), v = drone.dg.target(a);
Node hu = Index2h[UFNodes.find(u)], hv = Index2h[UFNodes.find(v)];
Edge e = h.addEdge(hu, hv); // add edges to the graph h
h_capacity[e] = (this->*solution_value)(x[a]);
}
#+end_source

Assim podemos usar a implementação do Gomory Hu provida pelo LEMON
#+begin_source c++
GomoryHu<Graph, EdgeValueMap> ght(h, h_capacity);
ght.run();
#+end_source
